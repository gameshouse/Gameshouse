<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tic Tac Toe Deluxe - Ultimate Premium Edition</title>
  <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Roboto:wght@400;500;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.js"></script>
  <style>
    :root {
      /* Original theme colors */
      --theme1: #4CAF50;
      --theme2: #ff5e62;
      --theme3: #2196F3;
      --theme4: #f9a602;
      --theme5: #9C27B0;

      /* Premium theme colors */
      --theme6: #2c3e50; /* Dark Blue */
      --theme7: #6a4c93; /* Royal Purple */
      --theme8: #1e847f; /* Teal */
      --theme9: #d63447; /* Ruby Red */
      --theme10: #3a6351; /* Forest Green */
      --theme11: #5d4257; /* Plum */
      --theme12: #1a1a2e; /* Midnight Blue */

      --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
      --premium-shadow: 0 10px 35px rgba(0, 0, 0, 0.2);
      --premium-shadow-hover: 0 15px 45px rgba(0, 0, 0, 0.25);
      --premium-gradient: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%);
      --cell-bg: #f3f3f3;
      --cell-shadow: 0 4px 12px 0 rgba(0,0,0,0.10);
      --win-bg: #fffbe6;
      --win-shadow: 0 0 24px 6px #ffe066;
      --score-bg: #fff;
      --score-shadow: 0 6px 24px 0 rgba(0,0,0,0.07);
      --font-main: 'Poppins', 'Montserrat', Arial, sans-serif;
      --font-body: 'Roboto', Arial, sans-serif;
      --main-color: var(--theme1); /* Default theme */
      --main-color-rgb: 76, 175, 80; /* Default RGB for theme1 */
      --bg-color: #ffffff;
      --text-color: #333333;
      --header-color: #222222;
      --border-color: #e0e0e0;
      --cell-tint-opacity-light: 0.08; /* Opacity for theme tint in light mode */
      --cell-tint-opacity-dark: 0.12; /* Opacity for theme tint in dark mode */
    }

    body {
      background: #f5f5f5;
      min-height: 100vh;
      margin: 0;
      font-family: var(--font-body);
      transition: background 0.5s;
    }

    body.dark-mode {
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --header-color: #f0f0f0;
      --border-color: #333333;
      --cell-bg: #2a2a2a;
      background: #121212;
    }

    .game-container {
      max-width: 480px;
      margin: 36px auto;
      background: rgba(255,255,255,0.96);
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 24px 12px 18px 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: background-color 0.5s;
    }

    body.dark-mode .game-container {
      background: rgba(30,30,30,0.95);
      color: var(--text-color);
    }

    h1 {
      font-family: var(--font-main);
      font-size: 2.2rem;
      font-weight: 800;
      color: var(--main-color);
      margin-bottom: 16px;
      letter-spacing: 2px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: color 0.3s;
      text-transform: uppercase;
    }

    body.dark-mode h1 {
      text-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }

    .controls {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .control-group {
      flex: 1 1 110px;
      min-width: 110px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      background: var(--premium-gradient), rgba(255,255,255,0.85);
      border-radius: 12px;
      padding: 8px 10px 5px 10px;
      box-shadow: var(--premium-shadow);
      margin-bottom: 4px;
      transition: all 0.3s ease;
      border: 1.5px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    .control-group:hover {
      box-shadow: var(--premium-shadow-hover);
      transform: translateY(-2px);
    }

    body.dark-mode .control-group {
      background: var(--premium-gradient), rgba(40,40,40,0.85);
      border-color: rgba(100,100,100,0.2);
    }

    .control-group label {
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--main-color);
      margin-bottom: 2px;
      font-family: var(--font-main);
      transition: color 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    body.dark-mode .control-group label {
      color: #e0e0e0;
    }

    select {
      width: 100%;
      padding: 6px 6px;
      border-radius: 8px;
      border: 1.5px solid var(--main-color);
      background: rgba(255,255,255,0.9);
      font-size: 0.9rem;
      font-family: var(--font-body);
      color: #333;
      outline: none;
      transition: all 0.3s;
      margin-bottom: 2px;
      cursor: pointer;
    }

    body.dark-mode select {
      background: rgba(60,60,60,0.9);
      color: #e0e0e0;
      border-color: var(--main-color);
    }

    select:focus {
      border: 1.5px solid var(--main-color);
      box-shadow: 0 0 0 2px rgba(var(--main-color-rgb), 0.25);
    }

    .color-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 2px;
    }

    .color-option {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.11);
      cursor: pointer;
      transition: transform 0.2s, border 0.2s;
      outline: 2px solid transparent;
    }

    body.dark-mode .color-option {
      border: 2px solid #333;
    }

    .color-option.selected {
      outline: 2px solid var(--main-color);
      transform: scale(1.16);
    }

    .emoji-selection {
      width: 100%;
      display: flex;
      justify-content: space-between;
      margin: 10px 0 2px 0;
      gap: 10px;
    }

    .emoji-group {
      flex: 1 1 110px;
      min-width: 110px;
      background: var(--premium-gradient), rgba(255,255,255,0.85);
      border-radius: 12px;
      padding: 8px 10px 5px 10px;
      box-shadow: var(--premium-shadow);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      transition: all 0.3s ease;
      border: 1.5px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    .emoji-group:hover {
      box-shadow: var(--premium-shadow-hover);
      transform: translateY(-2px);
    }

    body.dark-mode .emoji-group {
      background: var(--premium-gradient), rgba(40,40,40,0.85);
      border-color: rgba(100,100,100,0.2);
    }

    .emoji-group label {
      font-family: var(--font-main);
      color: var(--main-color);
      font-weight: 600;
      margin-bottom: 2px;
      transition: color 0.3s;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    body.dark-mode .emoji-group label {
      color: #e0e0e0;
    }

    .emoji-select {
      font-size: 1.3rem;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1.5px solid var(--main-color);
      background: rgba(255,255,255,0.9);
      outline: none;
      margin-bottom: 2px;
      transition: all 0.3s;
      cursor: pointer;
    }

    body.dark-mode .emoji-select {
      background: rgba(60,60,60,0.9);
      color: #fff;
    }

    .action-buttons {
      display: flex;
      gap: 12px;
      margin: 15px 0;
    }

    .btn {
      background: linear-gradient(90deg, var(--main-color) 0%, var(--main-color) 80%, rgba(255,255,255,0.2) 100%);
      color: #fff;
      font-family: var(--font-main);
      font-size: 1rem;
      border: none;
      border-radius: 10px;
      padding: 9px 22px;
      box-shadow: 0 4px 15px 0 rgba(0,0,0,0.15);
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 1px;
      transition: all 0.3s;
      text-transform: uppercase;
    }

    body.dark-mode .btn {
      background: linear-gradient(90deg, var(--main-color) 0%, var(--main-color) 80%, rgba(60,60,60,0.2) 100%);
    }

    .btn:hover {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, var(--main-color) 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px 0 rgba(0,0,0,0.2);
    }

    body.dark-mode .btn:hover {
      background: linear-gradient(90deg, rgba(60,60,60,0.1) 0%, var(--main-color) 100%);
    }

    .board {
      display: grid;
      gap: 12px;
      background: transparent;
      border-radius: 18px;
      margin-bottom: 18px;
      transition: box-shadow 0.3s;
    }

    .board-3 { grid-template-columns: repeat(3, 90px); grid-template-rows: repeat(3, 90px);}
    .board-4 { grid-template-columns: repeat(4, 70px); grid-template-rows: repeat(4, 70px);}
    .board-5 { grid-template-columns: repeat(5, 58px); grid-template-rows: repeat(5, 58px);}

    .cell {
      box-shadow: var(--cell-shadow);
      border-radius: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: var(--font-main);
      cursor: pointer;
      transition: all 0.3s ease-out;
      user-select: none;
      color: var(--main-color); /* Emoji color uses theme color */
      border: 2.5px solid var(--border-color);
      overflow: hidden;
      position: relative;
      background: linear-gradient(145deg, rgba(255,255,255,0.8), rgba(255,255,255,0.5));
    }

    /* Subtle theme color tint */
    .cell::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--main-color); /* Use theme color */
      opacity: var(--cell-tint-opacity-light); /* Use opacity variable */
      border-radius: 13px; /* Slightly smaller than cell radius */
      z-index: -1;
      transition: opacity 0.5s; /* Smooth transition for dark mode */
    }

    body.dark-mode .cell {
      background: linear-gradient(145deg, var(--cell-bg), #333);
      border-color: #444;
    }

    /* Update opacity for dark mode */
    body.dark-mode .cell::before {
      opacity: var(--cell-tint-opacity-dark);
    }

    .cell:hover {
      background: linear-gradient(145deg, #e0e0e0, #fff);
      box-shadow: 0 6px 18px 0 rgba(0,0,0,0.13);
      transform: translateY(-2px);
    }

    body.dark-mode .cell:hover {
      background: linear-gradient(145deg, #333, #444);
    }

    .cell:active {
      box-shadow: 0 2px 6px 0 rgba(0,0,0,0.10) inset;
      transform: translateY(0);
    }

    .cell.winner {
      background: var(--win-bg);
      box-shadow: var(--win-shadow);
      border: 2.5px solid var(--main-color);
      animation: pulse 1.1s infinite;
    }

    /* Proper emoji sizing for different grid sizes */
    .board-3 .cell .emoji-appear {
      font-size: 2.8rem;
    }

    .board-4 .cell .emoji-appear {
      font-size: 2.2rem;
    }

    .board-5 .cell .emoji-appear {
      font-size: 1.8rem;
    }

    /* Animation for when emojis appear */
    .emoji-appear {
      animation: emojiPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
    }

    @keyframes emojiPop {
      0% { transform: scale(0.2); opacity: 0.5; }
      70% { transform: scale(1.2); opacity: 0.9; }
      100% { transform: scale(1); opacity: 1; }
    }

    @keyframes pulse {
      0% { box-shadow: var(--win-shadow);}
      50% { box-shadow: 0 0 40px 14px #ffe066;}
      100% { box-shadow: var(--win-shadow);}
    }

    #gameStats {
      background: var(--premium-gradient), rgba(255,255,255,0.9);
      box-shadow: var(--premium-shadow);
      border-radius: 18px;
      padding: 12px 10px 10px 10px;
      width: 100%;
      max-width: 300px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: var(--font-main);
      font-size: 1rem;
      color: #444;
      letter-spacing: 1px;
      margin-bottom: 6px;
      border: 2px solid var(--main-color);
      transition: all 0.3s;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    #gameStats:hover {
      box-shadow: var(--premium-shadow-hover);
      transform: translateY(-2px);
    }

    body.dark-mode #gameStats {
      background: var(--premium-gradient), rgba(40,40,40,0.9);
      color: #e0e0e0;
    }

    .stat {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 75px;
      gap: 2px;
    }

    .stat .label {
      font-size: 0.8rem;
      font-family: var(--font-main);
      color: #888;
      margin-top: 2px;
      transition: color 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    body.dark-mode .stat .label {
      color: #aaa;
    }

    .stat .value {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--main-color);
      transition: color 0.3s;
    }

    .utility-buttons {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 15px;
    }

    .icon-btn {
      background: var(--main-color);
      color: white;
      border: none;
      border-radius: 50%;
      width: 38px;
      height: 38px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 4px 12px 0 rgba(0,0,0,0.15);
      transition: all 0.3s;
    }

    .icon-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px 0 rgba(0,0,0,0.2);
    }

    .icon-btn i {
      font-size: 1.1rem;
    }

    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
    }

    .modal.active {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background: white;
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 420px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      position: relative;
      transform: scale(0.9);
      transition: transform 0.3s;
    }

    body.dark-mode .modal-content {
      background: #212121;
      color: white;
    }

    .modal.active .modal-content {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-title {
      font-family: var(--font-main);
      font-size: 1.4rem;
      color: var(--main-color);
      font-weight: 700;
    }

    .close-modal {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #777;
      transition: color 0.3s;
    }

    body.dark-mode .close-modal {
      color: #aaa;
    }

    .close-modal:hover {
      color: var(--main-color);
    }

    .modal-body {
      font-family: var(--font-body);
      line-height: 1.5;
    }

    .modal-body h3 {
      color: var(--main-color);
      margin-top: 16px;
      margin-bottom: 8px;
      font-weight: 600;
    }

    .modal-body ol {
      padding-left: 20px;
    }

    .modal-body li {
      margin-bottom: 8px;
    }

    /* Enhanced Celebration Effects */
    @keyframes confetti-fall {
      0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }

    @keyframes sparkle {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(0); opacity: 0; }
    }

    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: var(--main-color);
      animation: confetti-fall 3.5s linear forwards;
      z-index: 100;
      pointer-events: none;
    }

    .sparkle {
      position: fixed;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--main-color);
      box-shadow: 0 0 10px 2px var(--main-color);
      animation: sparkle 1.5s linear infinite;
      z-index: 101;
      pointer-events: none;
    }

    .firework {
      position: fixed;
      z-index: 102;
      pointer-events: none;
    }

    .firework-particle {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: var(--main-color);
      box-shadow: 0 0 5px 1px var(--main-color);
      opacity: 1;
      transform-origin: center;
      animation: firework-expand 1s ease-out forwards;
    }

    @keyframes firework-expand {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }

    /* Winner popup */
    .popup {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      padding: 32px 40px 24px 40px;
      border-radius: 18px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.20);
      z-index: 999;
      text-align: center;
      font-family: var(--font-main);
      color: var(--main-color);
      font-size: 1.5rem;
      letter-spacing: 1px;
      animation: popup-in 0.6s cubic-bezier(.68,-0.55,.27,1.55);
    }

    body.dark-mode .popup {
      background: #212121;
      color: var(--main-color);
    }

    @keyframes popup-in {
      0% { transform: translate(-50%, -60%) scale(0.7);}
      100% { transform: translate(-50%, -50%) scale(1);}
    }

    .popup .celebrate {
      font-size: 2.5rem;
      margin-bottom: 6px;
      display: block;
    }

    /* Ad container styles with clear size specifications */
    .ad-container {
      margin: 20px auto;
      text-align: center;
      overflow: hidden;
      background: rgba(255,255,255,0.9);
      border-radius: 12px;
      padding: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      transition: all 0.3s;
      position: relative;
    }

    .ad-container::before {
      content: attr(data-ad-size);
      position: absolute;
      top: 0;
      left: 0;
      background: var(--main-color);
      color: white;
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 8px 0 8px 0;
      opacity: 0.9;
      z-index: 1;
    }

    body.dark-mode .ad-container {
      background: rgba(40,40,40,0.9);
    }

    .ad-top {
      width: 100%;
      max-width: 728px;
      height: 90px;
      margin-bottom: 20px;
    }

    .ad-middle {
      width: 100%;
      max-width: 300px;
      height: 250px;
      margin: 15px auto;
    }

    .ad-sticky {
      position: fixed;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      width: 160px;
      height: 600px;
      display: none; /* Hidden by default, shown on larger screens */
    }

    /* Feature lock badge with premium styling */
    .premium-badge {
      position: absolute;
      top: 0;
      right: 0;
      background: linear-gradient(135deg, var(--main-color), #f9a602);
      color: white;
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 0 8px 0 8px;
      z-index: 2;
      font-weight: 600;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .feature-lock {
      position: relative;
    }

    .feature-lock::after {
      content: '🔒';
      font-size: 0.8rem;
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
    }

    /* Premium Reward button styles */
    .reward-btn {
      background: linear-gradient(90deg, var(--main-color) 0%, #f9a602 100%);
      color: white;
      font-family: var(--font-main);
      font-size: 0.9rem;
      padding: 8px 16px;
      border-radius: 8px;
      border: none;
      font-weight: 600;
      margin-top: 16px;
      cursor: pointer;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.15);
    }

    .reward-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.2);
    }

    .reward-btn i {
      font-size: 1.1rem;
    }

    /* Improved premium feature advertisement */
    .premium-ad {
      background: linear-gradient(135deg, var(--main-color) 0%, #f9a602 100%);
      color: white;
      padding: 15px;
      border-radius: 12px;
      text-align: center;
      margin: 15px 0;
      box-shadow: 0 5px 20px rgba(0,0,0,0.2);
      position: relative;
      overflow: hidden;
    }

    .premium-ad::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
      animation: shine 2s infinite;
    }

    @keyframes shine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .premium-ad h3 {
      font-size: 1.1rem;
      margin-bottom: 10px;
      font-weight: 700;
    }

    .premium-ad p {
      font-size: 0.9rem;
      margin-bottom: 12px;
    }

    /* Responsive design */
    @media (min-width: 1200px) {
      .ad-sticky {
        display: block; /* Show sticky ad on large screens */
      }
    }

    @media (max-width: 600px) {
      .game-container { max-width: 98vw; padding: 8px 2vw 8px 2vw;}
      .board-3 { grid-template-columns: repeat(3, 70px); grid-template-rows: repeat(3, 70px);}
      .board-4 { grid-template-columns: repeat(4, 50px); grid-template-rows: repeat(4, 50px);}
      .board-5 { grid-template-columns: repeat(5, 40px); grid-template-rows: repeat(5, 40px);}

      /* Adjusted emoji sizes for smaller screens */
      .board-3 .cell .emoji-appear { font-size: 2.2rem; }
      .board-4 .cell .emoji-appear { font-size: 1.7rem; }
      .board-5 .cell .emoji-appear { font-size: 1.4rem; }

      .cell { border-radius: 12px;}
      #gameStats { font-size: 0.9rem;}
      .stat .value { font-size: 1.1rem;}
      .action-buttons { flex-wrap: wrap; justify-content: center; }
      .btn { font-size: 0.9rem; padding: 8px 16px; }
      .ad-top { height: 50px; } /* Adjust top ad height */

      .control-group, .emoji-group {
        min-width: 100px;
        padding: 6px 8px 4px 8px;
      }

      h1 {
        font-size: 1.8rem;
      }
    }

    @media (max-width: 400px) {
      .board-3 { grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px);}
      .board-4 { grid-template-columns: repeat(4, 42px); grid-template-rows: repeat(4, 42px);}
      .board-5 { grid-template-columns: repeat(5, 34px); grid-template-rows: repeat(5, 34px);}

      /* Adjusted emoji sizes for even smaller screens */
      .board-3 .cell .emoji-appear { font-size: 2rem; }
      .board-4 .cell .emoji-appear { font-size: 1.5rem; }
      .board-5 .cell .emoji-appear { font-size: 1.2rem; }

      .control-group, .emoji-group {
        min-width: 90px;
        flex: 1 1 90px;
      }

      .control-group label, .emoji-group label {
        font-size: 0.75rem;
      }

      select {
        font-size: 0.85rem;
      }

      .emoji-select {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <!-- Top Banner Ad (728x90) -->
  <div class="ad-container ad-top" data-ad-size="728×90">
    <div id="adsterra-top-banner">
      <!-- Placeholder for Adsterra Ad Code -->
      <img src="https://via.placeholder.com/728x90?text=Advertisement" alt="Advertisement" style="max-width:100%; height: auto;">
    </div>
  </div>

  <div class="game-container">
    <h1>Tic Tac Toe Deluxe</h1>
    <div class="controls">
      <div class="control-group">
        <label for="gridSize">Grid Size</label>
        <select id="gridSize">
          <option value="3" selected>3 × 3</option>
          <option value="4">4 × 4</option>
          <option value="5" class="feature-lock">5 × 5 (Premium)</option>
        </select>
      </div>
      <div class="control-group">
        <label for="difficulty">Difficulty</label>
        <select id="difficulty">
          <option value="easy" selected>Easy</option>
          <option value="medium">Medium</option>
          <option value="hard" class="feature-lock">Hard (Premium)</option>
        </select>
      </div>
      <div class="control-group">
        <label for="gameMode">Game Mode</label>
        <select id="gameMode">
          <option value="PvP" selected>Player vs Player</option>
          <option value="PvC">Player vs Computer</option>
        </select>
      </div>
      <div class="control-group">
        <label>Theme</label>
        <div class="color-picker">
          <div class="color-option selected" style="background: var(--theme1);" data-color="var(--theme1)" data-rgb="76, 175, 80"></div>
          <div class="color-option" style="background: var(--theme2);" data-color="var(--theme2)" data-rgb="255, 94, 98"></div>
          <div class="color-option" style="background: var(--theme3);" data-color="var(--theme3)" data-rgb="33, 150, 243"></div>
          <div class="color-option" style="background: var(--theme4);" data-color="var(--theme4)" data-rgb="249, 166, 2"></div>
          <div class="color-option" style="background: var(--theme5);" data-color="var(--theme5)" data-rgb="156, 39, 176"></div>
          <div class="color-option" style="background: var(--theme6);" data-color="var(--theme6)" data-rgb="44, 62, 80"></div>
          <div class="color-option" style="background: var(--theme7);" data-color="var(--theme7)" data-rgb="106, 76, 147"></div>
          <div class="color-option" style="background: var(--theme8);" data-color="var(--theme8)" data-rgb="30, 132, 127"></div>
          <div class="color-option" style="background: var(--theme9);" data-color="var(--theme9)" data-rgb="214, 52, 71"></div>
          <div class="color-option" style="background: var(--theme10);" data-color="var(--theme10)" data-rgb="58, 99, 81"></div>
          <div class="color-option" style="background: var(--theme11);" data-color="var(--theme11)" data-rgb="93, 66, 87"></div>
          <div class="color-option" style="background: var(--theme12);" data-color="var(--theme12)" data-rgb="26, 26, 46"></div>
        </div>
      </div>
    </div>
    <div class="emoji-selection">
      <div class="emoji-group">
        <label for="player1Emoji">Player 1</label>
        <select id="player1Emoji" class="emoji-select">
          <option>X</option> <!-- Default X -->
          <option>🐯</option>
          <option>🦄</option>
          <option>🦊</option>
          <option>🧙‍♂️</option>
          <option>🐉</option>
          <option>🦁</option>
          <option>😎</option>
          <option>🧑‍🚀</option>
          <option>🥷</option>
          <option>👑</option>
          <option>🦸‍♂️</option>
          <option>🧠</option>
        </select>
      </div>
      <div class="emoji-group">
        <label for="player2Emoji">Player 2</label>
        <select id="player2Emoji" class="emoji-select">
          <option>O</option> <!-- Default O -->
          <option>🐼</option>
          <option>👾</option>
          <option>🤖</option>
          <option>🦕</option>
          <option>🦸‍♀️</option>
          <option>🐧</option>
          <option>😈</option>
          <option>🧛‍♂️</option>
          <option>🦹‍♀️</option>
          <option>🌟</option>
          <option>🦝</option>
          <option>🎮</option>
        </select>
      </div>
    </div>
    <div class="action-buttons">
      <button id="newGameBtn" class="btn">New Game</button>
      <button id="restartBtn" class="btn">Restart</button>
    </div>
    <div id="board" class="board board-3"></div> <!-- Board initialized with 3x3 class -->

    <!-- Premium Feature Advertisement for 5x5 Grid -->
    <div class="premium-ad" id="grid5x5-ad" style="display:none;">
      <h3>Unlock 5×5 Grid!</h3>
      <p>Upgrade your game with a larger 5×5 grid for more challenging gameplay!</p>
      <button class="reward-btn" id="unlock5x5Btn">
        <i class="ri-vidicon-line"></i> Watch Ad to Unlock
      </button>
    </div>

    <!-- Premium Feature Advertisement for Hard Mode -->
    <div class="premium-ad" id="hardMode-ad" style="display:none;">
      <h3>Unlock Hard Mode!</h3>
      <p>Test your skills against our advanced AI in Hard difficulty mode!</p>
      <button class="reward-btn" id="unlockHardBtn">
        <i class="ri-vidicon-line"></i> Watch Ad to Unlock
      </button>
    </div>

    <!-- Middle Banner Ad (300x250) -->
    <div class="ad-container ad-middle" data-ad-size="300×250">
      <div id="adsterra-middle-banner">
        <!-- Placeholder for Adsterra Ad Code -->
        <img src="https://via.placeholder.com/300x250?text=Advertisement" alt="Advertisement" style="max-width:100%; height: auto;">
      </div>
    </div>

    <div id="gameStats">
      <div class="stat">
        <span class="value" id="player1Wins">0</span>
        <span class="label" id="p1Label">X Player 1</span> <!-- Initial Label -->
      </div>
      <div class="stat">
        <span class="value" id="draws">0</span>
        <span class="label">Draws</span>
      </div>
      <div class="stat">
        <span class="value" id="player2Wins">0</span>
        <span class="label" id="p2Label">O Player 2</span> <!-- Initial Label -->
      </div>
    </div>
    <div class="utility-buttons">
      <button id="howToPlayBtn" class="icon-btn"><i class="ri-question-line"></i></button>
      <button id="shareBtn" class="icon-btn"><i class="ri-share-line"></i></button>
      <button id="darkModeBtn" class="icon-btn"><i class="ri-moon-line"></i></button>
    </div>
  </div>

  <!-- Sticky Side Ad (160x600) for larger screens -->
  <div class="ad-container ad-sticky" data-ad-size="160×600">
    <div id="adsterra-sticky-banner">
      <!-- Placeholder for Adsterra Ad Code -->
      <img src="https://via.placeholder.com/160x600?text=Advertisement" alt="Advertisement" style="max-width:100%; height: auto;">
    </div>
  </div>

  <!-- How to Play Modal -->
  <div id="howToPlayModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">How to Play</div>
        <button class="close-modal">×</button>
      </div>
      <div class="modal-body">
        <h3>Game Setup</h3>
        <ol>
          <li>Choose your grid size: 3×3, 4×4, or 5×5 (premium)</li>
          <li>Select difficulty level (for computer opponent)</li>
          <li>Pick game mode: Player vs Player or Player vs Computer</li>
          <li>Choose your favorite theme color</li>
          <li>Select emoji characters for both players (Defaults are X and O)</li>
        </ol>

        <h3>Gameplay</h3>
        <ol>
          <li>Players take turns placing their emoji on the grid</li>
          <li>On a 3×3 grid, get **3 identical** emojis in a row to win</li>
          <li>On a 4×4 grid, get **4 identical** emojis in a row to win</li>
          <li>On a 5×5 grid, get **5 identical** emojis in a row to win</li>
          <li>Rows can be horizontal, vertical, or diagonal</li>
          <li>The winning line must contain *only* the winning player's emoji</li>
        </ol>

        <h3>Buttons</h3>
        <ul>
          <li><b>New Game:</b> Reset scores and start fresh</li>
          <li><b>Restart:</b> Start a new round but keep scores</li>
          <li><b>Share:</b> Share this game with friends</li>
          <li><b>Dark Mode:</b> Toggle between light and dark themes</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Premium Features Modal -->
  <div id="premiumFeatureModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Unlock Premium Feature</div>
        <button class="close-modal">×</button>
      </div>
      <div class="modal-body">
        <p id="premiumFeatureText">Watch an advertisement to unlock this premium feature for 24 hours!</p>
        <div style="text-align: center;">
          <button id="watchAdBtn" class="reward-btn">
            <i class="ri-vidicon-line"></i> Watch Ad to Unlock
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Interstitial Ad Modal -->
  <div id="interstitialModal" class="modal">
    <div class="modal-content" style="max-width: 650px;">
      <div class="modal-header">
        <div class="modal-title">Advertisement</div>
        <button class="close-modal">×</button>
      </div>
      <div class="modal-body" style="text-align: center;">
        <div id="adsterra-interstitial" data-ad-size="600×400">
          <!-- Placeholder for Adsterra Interstitial Ad Code -->
          <img src="https://via.placeholder.com/600x400?text=Advertisement" alt="Advertisement" style="max-width:100%; height: auto;">
        </div>
        <button id="closeAdBtn" class="btn" style="margin-top: 20px;">Continue to Game</button>
      </div>
    </div>
  </div>

  <!-- Sound Effects -->
  <audio id="clickSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_115b9c6b84.mp3" preload="auto"></audio>
  <audio id="winSound" src="https://cdn.pixabay.com/audio/2022/10/16/audio_12c3a1b1b0.mp3" preload="auto"></audio>
  <audio id="drawSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_123b3c0d7b.mp3" preload="auto"></audio>

  <script>
    // Game variables
    let currentPlayer = 1; // 1 or 2
    let gameBoard = []; // Stores player number (0, 1, or 2)
    let gameBoardEmojis = []; // Stores actual emoji ('X', 'O', '🐯', etc.)
    let gameActive = true;
    let gridSize = 3; // Default grid size
    let winningLength = 3; // How many in a row to win (updates with gridSize)
    let difficulty = 'easy';
    let gameMode = 'PvP';
    let stats = { player1Wins: 0, player2Wins: 0, draws: 0 };
    let lastWinner = 0; // Who won the last round (0 for draw, 1 or 2 for player)
    let isDarkMode = false;

    // Premium features tracking
    let premiumFeatures = {
      grid5x5: false,
      hardMode: false
    };

    // Feature unlock time tracking (in milliseconds from epoch)
    let featureUnlockTime = {
      grid5x5: 0,
      hardMode: 0
    };

    // Ad display counters
    let gamePlayCount = 0; // Counts number of games played since full reset or load
    let interstitialAdFrequency = 4; // Show interstitial ad every N games (Restart counts as a game)

    // DOM Elements Cache
    const boardElement = document.getElementById('board');
    const gridSizeSelect = document.getElementById('gridSize');
    const difficultySelect = document.getElementById('difficulty');
    const gameModeSelect = document.getElementById('gameMode');
    const player1EmojiSelect = document.getElementById('player1Emoji');
    const player2EmojiSelect = document.getElementById('player2Emoji');
    const newGameBtn = document.getElementById('newGameBtn');
    const restartBtn = document.getElementById('restartBtn');
    const player1WinsElement = document.getElementById('player1Wins');
    const player2WinsElement = document.getElementById('player2Wins');
    const drawsElement = document.getElementById('draws');
    const colorOptions = document.querySelectorAll('.color-option');
    const p1Label = document.getElementById('p1Label');
    const p2Label = document.getElementById('p2Label');
    const howToPlayBtn = document.getElementById('howToPlayBtn');
    const howToPlayModal = document.getElementById('howToPlayModal');
    const premiumFeatureModal = document.getElementById('premiumFeatureModal');
    const premiumFeatureText = document.getElementById('premiumFeatureText');
    const watchAdBtn = document.getElementById('watchAdBtn');
    const interstitialModal = document.getElementById('interstitialModal');
    const closeAdBtn = document.getElementById('closeAdBtn');
    const closeModalBtns = document.querySelectorAll('.close-modal');
    const shareBtn = document.getElementById('shareBtn');
    const darkModeBtn = document.getElementById('darkModeBtn');
    const grid5x5Ad = document.getElementById('grid5x5-ad');
    const hardModeAd = document.getElementById('hardMode-ad');
    const unlock5x5Btn = document.getElementById('unlock5x5Btn');
    const unlockHardBtn = document.getElementById('unlockHardBtn');

    // Sounds Cache
    const clickSound = document.getElementById('clickSound');
    const winSound = document.getElementById('winSound');
    const drawSound = document.getElementById('drawSound');

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', initializeGame);

    function initializeGame() {
      // Apply initial theme color CSS variables
      applyThemeColor(
        document.querySelector('.color-option.selected').getAttribute('data-color'),
        document.querySelector('.color-option.selected').getAttribute('data-rgb')
      );

      checkPremiumFeatures(); // Check local storage for unlocked features
      setupEventListeners();
      updateEmojiLabels(); // Set initial labels based on default X/O
      resetGame(); // Start the first game
      updatePremiumUI(); // Reflect premium status in UI elements
      showRelevantPremiumAds(); // Show ads for locked features if applicable
    }

    function setupEventListeners() {
      gridSizeSelect.addEventListener('change', handleGridSizeChange);
      difficultySelect.addEventListener('change', handleDifficultyChange);
      gameModeSelect.addEventListener('change', handleGameModeChange);
      newGameBtn.addEventListener('click', resetGame);
      restartBtn.addEventListener('click', handleRestartClick); // Use handler to check for ads
      player1EmojiSelect.addEventListener('change', handleEmojiChange);
      player2EmojiSelect.addEventListener('change', handleEmojiChange);
      unlock5x5Btn.addEventListener('click', () => showPremiumFeatureModal('grid5x5'));
      unlockHardBtn.addEventListener('click', () => showPremiumFeatureModal('hardMode'));
      watchAdBtn.addEventListener('click', simulateWatchingAd);
      closeAdBtn.addEventListener('click', () => interstitialModal.classList.remove('active'));
      howToPlayBtn.addEventListener('click', () => howToPlayModal.classList.add('active'));
      darkModeBtn.addEventListener('click', toggleDarkMode);
      shareBtn.addEventListener('click', shareGame);

      closeModalBtns.forEach(btn => btn.addEventListener('click', closeAllModals));
      document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', (e) => { if (e.target === modal) closeAllModals(); });
      });

      colorOptions.forEach((option) => {
        option.addEventListener('click', () => handleThemeChange(option));
      });

      // Add delegated event listener to the board for cell clicks
      boardElement.addEventListener('click', handleCellClick);

      // Periodically check premium feature expiry (e.g., every 5 minutes)
      setInterval(checkPremiumFeatures, 5 * 60 * 1000);
    }

    // --- Event Handlers ---

    function handleGridSizeChange(e) {
      const selectedSize = parseInt(e.target.value);

      if (selectedSize === 5 && !premiumFeatures.grid5x5) {
          e.preventDefault();
          // Reset dropdown visually back to current size
          setTimeout(() => { gridSizeSelect.value = gridSize; }, 0);
          showPremiumFeatureModal('grid5x5');
          return;
      }

      gridSize = selectedSize;
      winningLength = gridSize; // Crucial: Update winning length based on grid size
      resetBoard(); // Reset board state for new size
      showRelevantPremiumAds(); // Update which premium ads are shown
    }

    function handleDifficultyChange(e) {
        const selectedDifficulty = e.target.value;

        if (selectedDifficulty === 'hard' && !premiumFeatures.hardMode) {
            e.preventDefault();
            setTimeout(() => { difficultySelect.value = difficulty; }, 0);
            showPremiumFeatureModal('hardMode');
            return;
        }
        difficulty = selectedDifficulty;
        // No board reset needed unless game mode is PvC and a game is ongoing
        // For simplicity, we could reset, or just let it affect the *next* computer move.
        // Let's reset if game mode is PvC to ensure AI uses new difficulty immediately.
        if (gameMode === 'PvC') {
            resetBoard();
        }
        showRelevantPremiumAds();
    }

    function handleGameModeChange() {
      gameMode = gameModeSelect.value;
      resetBoard(); // Always reset board when changing mode
      showRelevantPremiumAds();
    }

    function handleEmojiChange() {
      updateEmojiLabels();
      resetBoard(); // Reset board to reflect new emojis immediately
    }

    function handleRestartClick() {
      gamePlayCount++; // Increment counter even on restart

      // Show interstitial ad occasionally before resetting board
      if (gamePlayCount > 1 && gamePlayCount % interstitialAdFrequency === 0) {
          showInterstitialAd(resetBoard); // Pass resetBoard as callback
      } else {
          resetBoard(); // Reset board directly
      }
    }

    function handleCellClick(event) {
        // Use event delegation: check if the clicked element is a cell
        const cell = event.target.closest('.cell');
        if (cell && gameActive) {
            const row = parseInt(cell.getAttribute('data-row'));
            const col = parseInt(cell.getAttribute('data-col'));
            if (!isNaN(row) && !isNaN(col)) { // Ensure row/col are valid numbers
                 makeMove(row, col);
            }
        }
    }

    function handleThemeChange(selectedOption) {
        colorOptions.forEach(o => o.classList.remove('selected'));
        selectedOption.classList.add('selected');
        const newColor = selectedOption.getAttribute('data-color');
        const newRgb = selectedOption.getAttribute('data-rgb');
        applyThemeColor(newColor, newRgb);
        // Optionally reset board to update cell tint immediately if desired,
        // though CSS transition on ::before handles it visually.
        // resetBoard(); // Uncomment if you prefer a hard reset on theme change
    }

    // --- Core Game Logic ---

    function resetGame() {
      currentPlayer = lastWinner > 0 ? lastWinner : 1; // Last winner starts next game
      stats = { player1Wins: 0, player2Wins: 0, draws: 0 };
      updateStatsDisplay();
      gamePlayCount = 0; // Reset ad counter only on 'New Game'
      resetBoard();
    }

    function resetBoard() {
      gameActive = true;
      boardElement.innerHTML = ''; // Clear previous cells
      boardElement.className = `board board-${gridSize}`; // Set correct grid class

      // Initialize game state arrays
      gameBoard = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
      gameBoardEmojis = Array(gridSize).fill(null).map(() => Array(gridSize).fill(''));

      // Create new cells
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.setAttribute('data-row', row);
          cell.setAttribute('data-col', col);
          // Event listener is now delegated to the boardElement
          boardElement.appendChild(cell);
        }
      }

      // If it's PvC and Computer's turn (Player 2), make the first move
      if (currentPlayer === 2 && gameMode === 'PvC' && gameActive) {
        setTimeout(makeComputerMove, 550); // Small delay for visual flow
      }
    }

    function makeMove(row, col) {
      if (gameBoard[row][col] !== 0 || !gameActive) return; // Ignore clicks on taken cells or inactive game

      playSound(clickSound);

      const currentEmoji = currentPlayer === 1 ? player1EmojiSelect.value : player2EmojiSelect.value;
      gameBoard[row][col] = currentPlayer;
      gameBoardEmojis[row][col] = currentEmoji; // Store the actual emoji used

      updateCellDisplay(row, col, currentEmoji);

      const winningLine = checkWin(row, col); // Check if this move wins
      if (winningLine) {
        gameActive = false;
        lastWinner = currentPlayer;
        highlightWinningCells(winningLine);
        updateScore(currentPlayer);
        showWinnerPopup(currentPlayer === 1 ? "Player 1" : "Player 2", currentEmoji);
        playSound(winSound);
        return; // Game over
      }

      if (checkDraw()) {
        gameActive = false;
        lastWinner = 0; // Indicate a draw for next round start
        updateScore(0); // 0 indicates a draw
        showDrawPopup();
        playSound(drawSound);
        return; // Game over
      }

      // Switch player
      currentPlayer = currentPlayer === 1 ? 2 : 1;

      // If PvC and now computer's turn, make its move
      if (currentPlayer === 2 && gameMode === 'PvC' && gameActive) {
        setTimeout(makeComputerMove, 600); // Add slight delay for AI 'thinking' time
      }
    }

    function checkWin(row, col) {
        // Checks for a win condition centered around the last move (row, col).
        // Requires exactly 'winningLength' consecutive, identical emojis.
        const player = gameBoard[row][col];
        const playerEmoji = gameBoardEmojis[row][col]; // Use the actual emoji for checking consistency

        if (player === 0) return null; // Should not happen if called after a move

        const directions = [
            { dr: 0, dc: 1 },  // Horizontal
            { dr: 1, dc: 0 },  // Vertical
            { dr: 1, dc: 1 },  // Diagonal \
            { dr: 1, dc: -1 }  // Diagonal /
        ];

        for (const { dr, dc } of directions) {
            let count = 1; // Start count at 1 for the cell just played
            let lineCells = [{ row, col }];

            // Check in the positive direction (dr, dc)
            for (let i = 1; i < winningLength; i++) {
                const nr = row + dr * i;
                const nc = col + dc * i;
                if (isValidCell(nr, nc) && gameBoard[nr][nc] === player && gameBoardEmojis[nr][nc] === playerEmoji) {
                    count++;
                    lineCells.push({ row: nr, col: nc });
                } else {
                    break; // Sequence broken
                }
            }

            // Check in the negative direction (-dr, -dc)
            for (let i = 1; i < winningLength; i++) {
                const nr = row - dr * i;
                const nc = col - dc * i;
                 if (isValidCell(nr, nc) && gameBoard[nr][nc] === player && gameBoardEmojis[nr][nc] === playerEmoji) {
                    count++;
                    lineCells.push({ row: nr, col: nc });
                } else {
                    break; // Sequence broken
                }
            }

            // Strict check: Did we find *exactly* winningLength consecutive cells?
            if (count >= winningLength) {
                 // Refine lineCells to only include the actual winning sequence
                 // Sort cells for consistent highlighting order (optional but clean)
                 lineCells.sort((a, b) => a.row - b.row || a.col - b.col);
                 // Extract the exact winning subsequence if count > winningLength (can happen on larger boards)
                 const winningSequence = findExactWinningSequence(lineCells, player, playerEmoji, dr, dc);
                 if (winningSequence) {
                    return winningSequence; // Return the array of winning cell coordinates
                 }
            }
        }

        return null; // No win found
    }

    function isValidCell(row, col) {
        return row >= 0 && row < gridSize && col >= 0 && col < gridSize;
    }

    function findExactWinningSequence(lineCells, player, playerEmoji, dr, dc) {
        // This function takes a potential line and extracts the first subsequence
        // of exactly `winningLength` matching cells. This prevents highlighting
        // longer lines incorrectly if the win condition is strictly N-in-a-row.
        if (lineCells.length < winningLength) return null;

        // Sort primarily by row, then column to handle all directions consistently
        lineCells.sort((a, b) => a.row - b.row || a.col - b.col);

        for (let i = 0; i <= lineCells.length - winningLength; i++) {
            const potentialSequence = lineCells.slice(i, i + winningLength);
            let isSequenceValid = true;

            // Check if this subsequence is consecutive in the direction of the win
            for (let j = 0; j < winningLength - 1; j++) {
                const cell1 = potentialSequence[j];
                const cell2 = potentialSequence[j + 1];
                // Check if cell2 is exactly one step away from cell1 in the winning direction OR opposite direction
                const rowDiff = Math.abs(cell1.row - cell2.row);
                const colDiff = Math.abs(cell1.col - cell2.col);

                // For horizontal/vertical, one diff is 1, other is 0. For diagonal, both are 1.
                const expectedRowDiff = Math.abs(dr);
                const expectedColDiff = Math.abs(dc);

                if (rowDiff !== expectedRowDiff || colDiff !== expectedColDiff) {
                     // Check if they are consecutive but in the opposite sort order (e.g., for / diagonal)
                     const reverseRowDiff = Math.abs(cell2.row - cell1.row);
                     const reverseColDiff = Math.abs(cell2.col - cell1.col);
                     if (reverseRowDiff !== expectedRowDiff || reverseColDiff !== expectedColDiff) {
                        isSequenceValid = false;
                        break;
                     }
                }
            }

            if (isSequenceValid) {
                // Double-check all cells in this sequence match the player/emoji (redundant but safe)
                if (potentialSequence.every(cell => gameBoard[cell.row][cell.col] === player && gameBoardEmojis[cell.row][cell.col] === playerEmoji)) {
                     return potentialSequence;
                }
            }
        }
        return null; // No exact sequence found
    }


    function checkDraw() {
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          if (gameBoard[row][col] === 0) {
            return false; // Found an empty cell, not a draw
          }
        }
      }
      return true; // All cells filled, it's a draw
    }

    // --- AI Logic ---

    function makeComputerMove() {
      if (!gameActive) return;

      let move;
      switch (difficulty) {
        case 'easy':
          // Easy: High chance of random move
          move = Math.random() < 0.8 ? findRandomMove() : findBasicOffensiveDefensiveMove();
          break;
        case 'medium':
          // Medium: Mix of strategy and randomness
          move = Math.random() < 0.3 ? findRandomMove() : findBetterStrategicMove();
          break;
        case 'hard':
          // Hard: Prioritize strategic moves (win > block > best heuristic)
          move = findBestMoveMinimaxStyle(); // Use more robust strategy
          break;
        default:
            move = findRandomMove(); // Fallback
      }

      // If strategy fails (e.g., board full unexpectedly), try random as a fallback
      if (!move) {
          move = findRandomMove();
      }

      // Make the chosen move if one was found
      if (move && isValidCell(move.row, move.col) && gameBoard[move.row][move.col] === 0) {
          makeMove(move.row, move.col);
      } else {
          // If even random move fails (shouldn't happen if checkDraw is correct), log error.
          console.error("AI failed to find a valid move.");
          // As a last resort, find *any* empty cell. This avoids getting stuck.
          const fallbackMove = findRandomMove();
          if (fallbackMove) {
              makeMove(fallbackMove.row, fallbackMove.col);
          }
      }
    }

    function findRandomMove() {
      const emptyCells = [];
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          if (gameBoard[row][col] === 0) {
            emptyCells.push({ row, col });
          }
        }
      }
      if (emptyCells.length > 0) {
        return emptyCells[Math.floor(Math.random() * emptyCells.length)];
      }
      return null; // No empty cells
    }

    function findBasicOffensiveDefensiveMove() {
        // Prioritize winning, then blocking, then random
        const winningMove = findWinningMoveForPlayer(2); // AI is player 2
        if (winningMove) return winningMove;

        const blockingMove = findWinningMoveForPlayer(1); // Block player 1
        if (blockingMove) return blockingMove;

        return findRandomMove();
    }

    function findBetterStrategicMove() {
        // Medium AI: Win > Block > Center (if available) > Corner (if available) > Random
        const winningMove = findWinningMoveForPlayer(2);
        if (winningMove) return winningMove;

        const blockingMove = findWinningMoveForPlayer(1);
        if (blockingMove) return blockingMove;

        // Try center (approximate for larger grids)
        const centerRow = Math.floor(gridSize / 2);
        const centerCol = Math.floor(gridSize / 2);
        if (gameBoard[centerRow][centerCol] === 0) {
            return { row: centerRow, col: centerCol };
        }
        // Check adjacent cells if center is taken (simple improvement)
        const centerNeighbors = [
            {r: centerRow-1, c: centerCol}, {r: centerRow+1, c: centerCol},
            {r: centerRow, c: centerCol-1}, {r: centerRow, c: centerCol+1},
            {r: centerRow-1, c: centerCol-1}, {r: centerRow-1, c: centerCol+1},
            {r: centerRow+1, c: centerCol-1}, {r: centerRow+1, c: centerCol+1}
        ];
        for(const n of centerNeighbors) {
            if(isValidCell(n.r, n.c) && gameBoard[n.r][n.c] === 0) {
                return {row: n.r, col: n.c};
            }
        }


        // Try corners
        const corners = [
            { row: 0, col: 0 }, { row: 0, col: gridSize - 1 },
            { row: gridSize - 1, col: 0 }, { row: gridSize - 1, col: gridSize - 1 }
        ];
        for (const corner of corners) {
            if (gameBoard[corner.row][corner.col] === 0) {
                return corner;
            }
        }

        return findRandomMove();
    }

     function findBestMoveMinimaxStyle() {
        // Hard AI: Win > Block > Find best move using heuristic evaluation
        const winningMove = findWinningMoveForPlayer(2); // AI is player 2
        if (winningMove) return winningMove;

        const blockingMove = findWinningMoveForPlayer(1); // Block player 1
        if (blockingMove) return blockingMove;

        // If no immediate win/block, evaluate potential moves
        let bestScore = -Infinity;
        let bestMove = null;
        const emptyCells = [];

        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                if (gameBoard[row][col] === 0) {
                    emptyCells.push({ row, col });
                }
            }
        }

        // Shuffle empty cells to add variability for equally good moves
        shuffleArray(emptyCells);

        for (const cell of emptyCells) {
            // Simulate making the move for AI (player 2)
            gameBoard[cell.row][cell.col] = 2;
            gameBoardEmojis[cell.row][cell.col] = player2EmojiSelect.value; // Use actual emoji

            // Basic heuristic: evaluate the board state after this move
            // A simple heuristic could count potential winning lines
            const score = evaluateBoardStateSimple();

            // Undo the simulated move
            gameBoard[cell.row][cell.col] = 0;
            gameBoardEmojis[cell.row][cell.col] = '';

            if (score > bestScore) {
                bestScore = score;
                bestMove = { row: cell.row, col: cell.col };
            }
        }

        // Fallback to random if no strategic move identified (should be rare)
        return bestMove || findRandomMove();
    }

    function findWinningMoveForPlayer(player) {
        // Checks if 'player' has an immediate winning move available
        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                if (gameBoard[row][col] === 0) {
                    // Temporarily make the move
                    gameBoard[row][col] = player;
                    // Use the correct emoji for the check
                    gameBoardEmojis[row][col] = player === 1 ? player1EmojiSelect.value : player2EmojiSelect.value;

                    const isWin = checkWin(row, col); // Check if this move wins

                    // Undo the move
                    gameBoard[row][col] = 0;
                    gameBoardEmojis[row][col] = '';

                    if (isWin) {
                        return { row, col }; // Found a winning/blocking move
                    }
                }
            }
        }
        return null; // No immediate winning move found
    }

    function evaluateBoardStateSimple() {
        // Simple heuristic: Give score based on potential lines for AI vs opponent
        // +1 for each potential line for AI, -1 for each potential line for opponent
        // More sophisticated heuristics would weigh lines with more pieces higher.
        let score = 0;
        const player = 2; // AI
        const opponent = 1;

        // Evaluate potential lines (rows, cols, diagonals)
        // This is a basic count, not considering pieces already in line
        score += countPotentialLines(player) - countPotentialLines(opponent);

        return score;
    }

    function countPotentialLines(player) {
       // Counts lines where 'player' could potentially win (not blocked by opponent)
        let potentialLines = 0;
        const opponent = player === 1 ? 2 : 1;

        // Check rows
        for (let r = 0; r < gridSize; r++) {
            if (isLinePotential(r, 0, 0, 1, player, opponent)) potentialLines++;
        }
        // Check columns
        for (let c = 0; c < gridSize; c++) {
            if (isLinePotential(0, c, 1, 0, player, opponent)) potentialLines++;
        }
        // Check diagonals
        if (isLinePotential(0, 0, 1, 1, player, opponent)) potentialLines++;
        if (isLinePotential(0, gridSize - 1, 1, -1, player, opponent)) potentialLines++;

        // Add checks for off-center diagonals on larger boards if needed for better heuristic

        return potentialLines;
    }

    function isLinePotential(startRow, startCol, dr, dc, player, opponent) {
        // Checks if a line starting at (startRow, startCol) in direction (dr, dc)
        // is still a potential winning line for 'player' (i.e., contains no 'opponent' pieces)
        for (let i = 0; i < gridSize; i++) {
            const r = startRow + i * dr;
            const c = startCol + i * dc;
            if (isValidCell(r, c)) {
                if (gameBoard[r][c] === opponent) {
                    return false; // Opponent blocks this line
                }
            } else {
                // This check assumes lines wrap or are padded - adjust if needed
                // For simple TicTacToe, lines end at boundaries. If we reach here,
                // it means the line didn't fit fully on the board in this direction.
                // Depending on rules (e.g., only full lines count), handle appropriately.
                // For this simple heuristic, we can assume it's not a valid line if it goes off board.
                 if (i < winningLength) return false; // Cannot form winning length if cut short
            }
        }
        return true; // No opponent found, line is potential
    }

    // Utility to shuffle array (Fisher-Yates algorithm)
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }


    // --- UI Updates & Display ---

    function updateCellDisplay(row, col, emoji) {
      const cell = boardElement.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
      if (cell) {
        cell.innerHTML = ''; // Clear previous content (if any)
        const emojiSpan = document.createElement('span');
        emojiSpan.className = 'emoji-appear'; // Add animation class
        emojiSpan.textContent = emoji;
        cell.appendChild(emojiSpan);
        // Remove click listener after move? Not needed with event delegation.
        // cell.removeEventListener('click', handleCellClick); // Example if not using delegation
      }
    }

    function highlightWinningCells(cells) {
        if (!cells) return;
        cells.forEach(cellCoords => {
            const cellElement = boardElement.querySelector(`.cell[data-row="${cellCoords.row}"][data-col="${cellCoords.col}"]`);
            if (cellElement) {
                cellElement.classList.add('winner'); // Apply winning style
            }
        });
    }

    function updateEmojiLabels() {
      p1Label.textContent = `${player1EmojiSelect.value} Player 1`;
      p2Label.textContent = `${player2EmojiSelect.value} Player 2`;
    }

    function updateStatsDisplay() {
      player1WinsElement.textContent = stats.player1Wins;
      player2WinsElement.textContent = stats.player2Wins;
      drawsElement.textContent = stats.draws;
    }

    function updateScore(winner) {
      if (winner === 1) {
        stats.player1Wins++;
      } else if (winner === 2) {
        stats.player2Wins++;
      } else if (winner === 0) { // Draw
        stats.draws++;
      }
      updateStatsDisplay();
    }

    function applyThemeColor(colorVar, rgbVar) {
        document.documentElement.style.setProperty('--main-color', colorVar);
        document.documentElement.style.setProperty('--main-color-rgb', rgbVar);
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      isDarkMode = document.body.classList.contains('dark-mode');
      darkModeBtn.querySelector('i').className = isDarkMode ? 'ri-sun-line' : 'ri-moon-line';
      // Update cell tint opacity based on mode (though CSS vars handle this now)
    }

    function showWinnerPopup(winnerName, winnerEmoji) {
      const popup = document.createElement('div');
      popup.className = `popup ${isDarkMode ? 'dark-mode' : ''}`; // Apply dark mode if needed
      popup.innerHTML = `<span class="celebrate">🎉</span><div>${winnerEmoji} ${winnerName} Wins!</div>`;
      document.body.appendChild(popup);
      createPremiumCelebration(); // Trigger confetti/sparkles
      setTimeout(() => { popup.remove(); }, 3000); // Popup duration
    }

    function showDrawPopup() {
      const popup = document.createElement('div');
      popup.className = `popup ${isDarkMode ? 'dark-mode' : ''}`;
      popup.innerHTML = `<span class="celebrate">🤝</span><div>It's a Draw!</div>`;
      document.body.appendChild(popup);
      setTimeout(() => { popup.remove(); }, 1600);
    }

    // --- Premium Features & Ads ---

    function checkPremiumFeatures() {
      const currentTime = new Date().getTime();

      // Check 5x5 grid unlock status
      const savedGrid5x5Time = localStorage.getItem('grid5x5UnlockTime');
      if (savedGrid5x5Time && parseInt(savedGrid5x5Time) > currentTime) {
        premiumFeatures.grid5x5 = true;
        featureUnlockTime.grid5x5 = parseInt(savedGrid5x5Time);
      } else {
        premiumFeatures.grid5x5 = false;
        localStorage.removeItem('grid5x5UnlockTime');
        // If the user was playing 5x5 when it expired, reset to 3x3
        if (gridSize === 5) {
            gridSize = 3;
            winningLength = 3;
            gridSizeSelect.value = '3';
            resetBoard();
        }
      }

      // Check Hard mode unlock status
      const savedHardModeTime = localStorage.getItem('hardModeUnlockTime');
      if (savedHardModeTime && parseInt(savedHardModeTime) > currentTime) {
        premiumFeatures.hardMode = true;
        featureUnlockTime.hardMode = parseInt(savedHardModeTime);
      } else {
        premiumFeatures.hardMode = false;
        localStorage.removeItem('hardModeUnlockTime');
        // If user was playing hard when it expired, reset to medium
        if (difficulty === 'hard') {
            difficulty = 'medium';
            difficultySelect.value = 'medium';
            if(gameMode === 'PvC') resetBoard();
        }
      }

      updatePremiumUI(); // Update select options (lock icons)
      showRelevantPremiumAds(); // Show/hide ads based on current status
    }

    function updatePremiumUI() {
      const grid5x5Option = gridSizeSelect.querySelector('option[value="5"]');
      const hardModeOption = difficultySelect.querySelector('option[value="hard"]');

      if (grid5x5Option) {
        grid5x5Option.textContent = premiumFeatures.grid5x5 ? "5 × 5" : "5 × 5 (Premium)";
        grid5x5Option.classList.toggle('feature-lock', !premiumFeatures.grid5x5);
      }
      if (hardModeOption) {
        hardModeOption.textContent = premiumFeatures.hardMode ? "Hard" : "Hard (Premium)";
        hardModeOption.classList.toggle('feature-lock', !premiumFeatures.hardMode);
      }
    }

    function showRelevantPremiumAds() {
        // Show 5x5 ad ONLY if 4x4 is selected AND 5x5 is locked
        grid5x5Ad.style.display = (gridSize === 4 && !premiumFeatures.grid5x5) ? 'block' : 'none';

        // Show Hard mode ad ONLY if Medium is selected, PvC mode is active, AND Hard is locked
        hardModeAd.style.display = (difficulty === 'medium' && gameMode === 'PvC' && !premiumFeatures.hardMode) ? 'block' : 'none';
    }


    function showPremiumFeatureModal(feature) {
      const featureName = feature === 'grid5x5' ? '5×5 Grid' : 'Hard Mode';
      premiumFeatureText.textContent = `Watch an advertisement to unlock the ${featureName} for 24 hours!`;
      watchAdBtn.setAttribute('data-feature', feature); // Store which feature to unlock
      premiumFeatureModal.classList.add('active');
    }

    function simulateWatchingAd() {
      const feature = watchAdBtn.getAttribute('data-feature');
      premiumFeatureModal.classList.remove('active');

      // --- !!! AD INTEGRATION POINT !!! ---
      // Here you would typically call your ad network's function
      // to display a rewarded video ad.
      // For this example, we'll simulate success with a timeout.
      console.log(`Simulating rewarded ad for feature: ${feature}`);
      showInterstitialAd(() => { // Use interstitial modal as placeholder
          // --- !!! AD SUCCESS CALLBACK !!! ---
          // This code should run *only* after the ad network confirms
          // the user successfully watched the ad.
          console.log(`Ad simulation complete for: ${feature}`);
          unlockFeature(feature);
          const featureName = feature === 'grid5x5' ? '5×5 Grid' : 'Hard Mode';
           // Use a non-blocking notification instead of alert
          showTemporaryNotification(`${featureName} unlocked for 24 hours!`);
          // Ensure the UI updates correctly after unlock
           if (feature === 'grid5x5') gridSizeSelect.value = '5';
           if (feature === 'hardMode') difficultySelect.value = 'hard';
           handleGridSizeChange({ target: gridSizeSelect }); // Trigger updates
           handleDifficultyChange({ target: difficultySelect }); // Trigger updates
      });
    }

    function unlockFeature(feature) {
      const currentTime = new Date().getTime();
      const unlockDuration = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

      if (feature === 'grid5x5') {
        premiumFeatures.grid5x5 = true;
        featureUnlockTime.grid5x5 = currentTime + unlockDuration;
        localStorage.setItem('grid5x5UnlockTime', featureUnlockTime.grid5x5.toString());
      } else if (feature === 'hardMode') {
        premiumFeatures.hardMode = true;
        featureUnlockTime.hardMode = currentTime + unlockDuration;
        localStorage.setItem('hardModeUnlockTime', featureUnlockTime.hardMode.toString());
      }
      updatePremiumUI();
      showRelevantPremiumAds();
    }

    function showInterstitialAd(callbackOnClose) {
        // --- !!! AD INTEGRATION POINT !!! ---
        // Here you would display your interstitial ad using your ad network's SDK.
        // For this example, we just show the modal.
        console.log("Showing interstitial ad modal simulation.");
        interstitialModal.classList.add('active');

        // Reset previous listener before adding a new one
        const newCloseAdBtn = closeAdBtn.cloneNode(true);
        closeAdBtn.parentNode.replaceChild(newCloseAdBtn, closeAdBtn);
       // closeAdBtn = newCloseAdBtn; // Update reference if needed elsewhere

        newCloseAdBtn.onclick = () => {
            console.log("Interstitial ad modal closed by user.");
            interstitialModal.classList.remove('active');
            if (callbackOnClose && typeof callbackOnClose === 'function') {
                callbackOnClose(); // Execute the callback after closing
            }
        };
    }

    function closeAllModals() {
      document.querySelectorAll('.modal.active').forEach(modal => {
        modal.classList.remove('active');
      });
    }

     function showTemporaryNotification(message) {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.bottom = '20px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.background = 'var(--main-color)';
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '8px';
        notification.style.zIndex = '2000';
        notification.style.boxShadow = '0 4px 15px rgba(0,0,0,0.2)';
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.5s ease-in-out';
        document.body.appendChild(notification);

        // Fade in
        setTimeout(() => { notification.style.opacity = '1'; }, 10);

        // Fade out and remove
        setTimeout(() => { notification.style.opacity = '0'; }, 3000);
        setTimeout(() => { notification.remove(); }, 3500);
    }


    // --- Utilities & Effects ---

    function playSound(audioElement) {
       if (audioElement) {
           audioElement.currentTime = 0; // Rewind to start
           audioElement.play().catch(error => console.debug("Audio play interrupted:", error)); // Play, catch errors silently
       }
    }

    async function shareGame() {
      const shareData = {
        title: 'Tic Tac Toe Deluxe',
        text: 'Challenge me in Tic Tac Toe Deluxe - Ultimate Premium Edition!',
        url: window.location.href // Share the current page URL
      };
      try {
        if (navigator.share) {
            await navigator.share(shareData);
            console.log('Game shared successfully');
        } else {
            // Fallback for browsers that don't support navigator.share
            showTemporaryNotification('Sharing not supported, copy the URL!');
        }
      } catch (err) {
        console.error('Error sharing:', err);
        // Don't show alert if user cancels share dialog
        if (err.name !== 'AbortError') {
            showTemporaryNotification('Could not share game.');
        }
      }
    }

    // --- Celebration Effects (Confetti, Sparkles, Fireworks) ---
    // Keep the existing celebration functions:
    // createPremiumCelebration, createConfetti, createSparkles, createFirework

    function createPremiumCelebration() {
      const mainColor = getComputedStyle(document.documentElement).getPropertyValue('--main-color').trim();
      const sparkleColors = [mainColor, '#FFD700', '#FFFFFF', '#C0C0C0']; // Theme, Gold, White, Silver
      const confettiColors = [mainColor, '#ff5e62', '#2196F3', '#f9a602', '#9C27B0', '#FFFFFF']; // Mix of themes + white

      createConfetti(120, confettiColors);
      createSparkles(80, sparkleColors);
      for (let i = 0; i < 5; i++) { // Fewer fireworks for potentially better performance
        setTimeout(() => {
          createFirework(sparkleColors);
        }, i * 250); // Slightly faster bursts
      }
    }

    function createConfetti(count = 100, colors) {
      const container = document.body; // Append to body
      for (let i = 0; i < count; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti'; // Use existing class
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.width = `${Math.random() * 8 + 4}px`; // Slightly smaller
        confetti.style.height = confetti.style.width;
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.opacity = `${Math.random() * 0.5 + 0.5}`; // Vary opacity
        confetti.style.animationDuration = `${Math.random() * 1 + 2.5}s`; // Adjust timing
        confetti.style.animationDelay = `${Math.random() * 0.5}s`;
        container.appendChild(confetti);
        setTimeout(() => { confetti.remove(); }, 4000); // Cleanup
      }
    }

    function createSparkles(count = 50, colors) {
        const container = document.body;
        for (let i = 0; i < count; i++) {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle'; // Use existing class
            sparkle.style.position = 'fixed'; // Ensure they stay relative to viewport
            sparkle.style.left = `${Math.random() * 100}%`;
            sparkle.style.top = `${Math.random() * 100}%`;
            sparkle.style.width = `${Math.random() * 4 + 4}px`; // Smaller sparkles
            sparkle.style.height = sparkle.style.width;
            const color = colors[Math.floor(Math.random() * colors.length)];
            sparkle.style.backgroundColor = color;
            sparkle.style.boxShadow = `0 0 8px 2px ${color}`; // Adjust shadow
            sparkle.style.animationDuration = `${Math.random() * 0.8 + 0.7}s`; // Faster sparkle
            sparkle.style.animationDelay = `${Math.random() * 1.5}s`;
            container.appendChild(sparkle);
            setTimeout(() => { sparkle.remove(); }, 2500); // Faster cleanup
        }
    }

    function createFirework(colors) {
        const container = document.body;
        const firework = document.createElement('div');
        firework.className = 'firework'; // Use existing class
        firework.style.left = `${Math.random() * 80 + 10}%`; // Avoid extreme edges
        firework.style.top = `${Math.random() * 50 + 10}%`; // Higher up
        container.appendChild(firework);

        const particleCount = 30 + Math.floor(Math.random() * 20); // Variable particle count
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'firework-particle'; // Use existing class
            const color = colors[Math.floor(Math.random() * colors.length)];
            particle.style.backgroundColor = color;
            particle.style.boxShadow = `0 0 4px 1px ${color}`; // Adjust shadow

            const angle = Math.random() * Math.PI * 2; // Random angle
            const distance = Math.random() * 80 + 50; // Variable distance
            const tx = Math.cos(angle) * distance;
            const ty = Math.sin(angle) * distance;

            particle.style.setProperty('--tx', `${tx}px`);
            particle.style.setProperty('--ty', `${ty}px`);
            particle.style.animationDuration = `${0.7 + Math.random() * 0.5}s`; // Adjust speed
            firework.appendChild(particle);
        }

        setTimeout(() => { firework.remove(); }, 1500); // Faster cleanup
    }


    // --- Ad Placeholder Initialization ---
    // Add actual Adsterra (or other network) init code here if available
    function initializeAds() {
      console.log("Initializing Ad placeholders. Replace with actual ad code.");
      // Example: You might have Adsterra banner code to insert into
      // #adsterra-top-banner, #adsterra-middle-banner, etc.
    }

    // Call ad init (can be called after DOMContentLoaded or later)
    initializeAds();

  </script>
</body>
</html>
